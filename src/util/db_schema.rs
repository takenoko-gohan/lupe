use chrono::Utc;
use typed_builder::TypedBuilder;

#[derive(TypedBuilder)]
pub(crate) struct AlbLogsRow {
    conn_type: Option<String>,
    time: Option<chrono::DateTime<Utc>>,
    elb: Option<String>,
    client_port: Option<String>,
    target_port: Option<String>,
    request_processing_time: Option<f64>,
    target_processing_time: Option<f64>,
    response_processing_time: Option<f64>,
    elb_status_code: Option<i32>,
    target_status_code: Option<String>,
    received_bytes: Option<i64>,
    sent_bytes: Option<i64>,
    request: Option<String>,
    user_agent: Option<String>,
    ssl_cipher: Option<String>,
    ssl_protocol: Option<String>,
    target_group_arn: Option<String>,
    trace_id: Option<String>,
    domain_name: Option<String>,
    chosen_cert_arn: Option<String>,
    matched_rule_priority: Option<String>,
    request_creation_time: Option<chrono::DateTime<Utc>>,
    actions_executed: Option<String>,
    redirect_url: Option<String>,
    error_reason: Option<String>,
    target_port_list: Option<String>,
    target_status_code_list: Option<String>,
    classification: Option<String>,
    classification_reason: Option<String>,
    conn_trace_id: Option<String>,
}

impl AlbLogsRow {
    pub(crate) fn get_field(&self, field_name: &str) -> Option<String> {
        match field_name {
            "type" => self.conn_type.clone(),
            "time" => self.time.map(|v| v.to_string()),
            "elb" => self.elb.clone(),
            "client_port" => self.client_port.clone(),
            "target_port" => self.target_port.clone(),
            "request_processing_time" => self.request_processing_time.map(|v| v.to_string()),
            "target_processing_time" => self.target_processing_time.map(|v| v.to_string()),
            "response_processing_time" => self.response_processing_time.map(|v| v.to_string()),
            "elb_status_code" => self.elb_status_code.map(|v| v.to_string()),
            "target_status_code" => self.target_status_code.clone(),
            "received_bytes" => self.received_bytes.map(|v| v.to_string()),
            "sent_bytes" => self.sent_bytes.map(|v| v.to_string()),
            "request" => self.request.clone(),
            "user_agent" => self.user_agent.clone(),
            "ssl_cipher" => self.ssl_cipher.clone(),
            "ssl_protocol" => self.ssl_protocol.clone(),
            "target_group_arn" => self.target_group_arn.clone(),
            "trace_id" => self.trace_id.clone(),
            "domain_name" => self.domain_name.clone(),
            "chosen_cert_arn" => self.chosen_cert_arn.clone(),
            "matched_rule_priority" => self.matched_rule_priority.clone(),
            "request_creation_time" => self.request_creation_time.map(|v| v.to_string()),
            "actions_executed" => self.actions_executed.clone(),
            "redirect_url" => self.redirect_url.clone(),
            "error_reason" => self.error_reason.clone(),
            "target_port_list" => self.target_port_list.clone(),
            "target_status_code_list" => self.target_status_code_list.clone(),
            "classification" => self.classification.clone(),
            "classification_reason" => self.classification_reason.clone(),
            "conn_trace_id" => self.conn_trace_id.clone(),
            _ => None,
        }
    }
}
